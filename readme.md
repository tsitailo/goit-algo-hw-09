# Порівняння ефективності алгоритмів видачі решти

У цьому завданні було реалізовано два підходи до задачі про розбиття суми на монети: Жадібний алгоритм та Динамічне програмування.

## 1. Жадібний алгоритм (`find_coins_greedy`)

- **Принцип роботи:** На кожному кроці вибирає монету найбільшого номіналу, яка не перевищує поточну суму залишку.
- **Часова складність:** $O(N)$, де $N$ — кількість номіналів монет. Оскільки кількість номіналів фіксована і мала (6 штук), алгоритм працює майже миттєво ($O(1)$ відносно суми).
- **Продуктивність:** Дуже висока. Навіть для дуже великих сум (наприклад, 1 000 000) він виконується за частки секунди, оскільки просто виконує кілька операцій ділення.
- **Недоліки:** Для "канонічних" монетних систем (як у більшості валют світу, включаючи наш приклад) він дає оптимальний результат. Однак, для деяких специфічних наборів монет (наприклад, `[4, 3, 1]`) жадібний підхід може не знайти оптимального рішення (для суми 6 він дасть `4+1+1`, хоча оптимально `3+3`).

## 2. Алгоритм динамічного програмування (`find_min_coins`)

- **Принцип роботи:** Будує рішення для всіх сум від 1 до заданої суми $S$, знаходячи мінімальну кількість монет для кожної проміжної суми на основі попередніх обчислень.
- **Часова складність:** $O(S \times N)$, де $S$ — сума, яку треба видати, а $N$ — кількість номіналів монет. Час виконання лінійно залежить від величини суми.
- **Продуктивність:** Прийнятна для малих сум. Проте при збільшенні суми $S$, час виконання і споживання пам'яті значно зростають. Для дуже великих сум цей метод стає повільним, оскільки потрібно заповнити масив розміром $S$.
- **Переваги:** Гарантовано знаходить мінімальну кількість монет для будь-якого набору номіналів, навіть якщо жадібний алгоритм не справляється.

## Висновки

1. **Швидкість:** Жадібний алгоритм значно швидший за алгоритм динамічного програмування. Час його виконання не залежить від величини суми (він залежить лише від кількості номіналів). Час виконання динамічного алгоритму зростає пропорційно сумі.
2. **Доцільність:**
   - Для стандартних монетних систем (гривні, долари, євро) **Жадібний алгоритм** є кращим вибором через його абсолютну перевагу в швидкості та пам'яті.
   - **Динамічне програмування** варто застосовувати лише у випадках, коли набір монет є нестандартним і жадібний підхід не гарантує оптимального рішення, або коли суми для обчислення є відносно невеликими.
